1.void  不可以定义普通类型，只可以void* 因为不知道分配多大内存，而指针内存大小固定，和系统有关
2.char *p = "123"  p在栈区 123 在全局区(这是指针指向) 用指针              char p[]="123"p[]分配在栈，123分配在全局区 （这是数据拷贝过来到buf）;系统自动释放buf，调用完打印可能乱码  可以用malloc解决，放在堆区，人为释放
3.void* 使用的时候要转换为相应的类型
4.指针没有空间就不要给他拷贝内容
5.c和c++兼容编译可以引用  一些宏定义  上网搜
6. *p =buf[10]   %d p+1 和 &buf+1不一样
7.*p = "121243543" 与buf[] = "121243543"   buf可以改，，因为是拷贝    实质就是写内存时要确保内存可写（例如NULL不行）   如*p = "123",strcpy(p,"123"),不行因为p不能写“123"在文字常量区，如果是数组就行，实质是拷贝
8.0与\0等价 而与字符‘0’不同   字符串处理，初始化等注意
9.strstr()查找字符串  返回首地址
10.const 修饰变量为只读（c语言的const是假的const  C++真的）        const     修饰指针看法：从左往右，不看类型 const后面是*说明指针指向的内存不可以改，如果是变量名说明指针的指向不能改，即指针的值不能改
11.指针之间没加&传递就是平级传递  和int a = b一样
12.函数调用 void get(int ** p)  <1>mian 调用 int * a get(&a） <2>自己传出malloc *tem=malloc(...)这里减少一个*    *p = temp
13.手动二维内存 char*arry[3]   先char**malloc（*char）   再buf[i] char* malloc(char) 
14.strcat拼接字符串
15 **二级指针作用无非就是要么动态分配空间，要么把地址值修改释放
16.a[i] a 代表首元素地址 &a代表整个数组首地址，虽然地址一样，但是步长不同  
17.指针数组 int* arry[]   数组指针通常和tydef结合 A* a    有typedef就是类型 没有就是变量
18二维数组 a[][]    a:代表第0行首地址/ a+i == &a[i]:代表第i行首地址/ *(a+i)==a[i]:代表第0行首元素地址 /*(a+i)+j == &a[i][j]:第i行第j列元素地址/*(*(a+i)+j)==a[i][j]第i行第j列元素的值
19.int (*p)[4]数组指针   typedef int(*P)[4]   P p;
20.定义结构体时不要初始化，因为结构体是一个类型 比如int char ,只有定义变量后才分配空间 如int a;
21.深拷贝和浅拷贝问题对c语言影响不大（只要不人为释放两次）人为动态分配内存，对c++影响较大，因为c++有析构函数
22.结构体字节对齐 是以最长数据类型对齐   1*0 2*1........   不够的补*    #pragma pack(2)  指定以2个字节对齐  超过的也要这样   局限性不能指定超过数据里的最大 如最大int  不能（8）
23.文件操作  day06-4挺好（c提高）  步骤：打开-写数据-关闭    stdio.h   缓冲区刷新一般面试题  文件句柄   sprintf 字符串用的 printf 标准的 fprintf 文件的
    feof(fp) 判断文件是否结束  结束返回true
    设备文件 :stdin stdout stderr屏幕键盘错误码
    随机位置读取文件fseek()
    获取光标距离文件开头的字节数ftell()   光标移到末尾调用它就可以获取文件大小
24.加密解密
25.单向链表一定掌握
26.c语言通过回调函数实现c++多态
27.链表（动态*、静态/ 有头*、无头）
28.结构体A可以嵌套结构体B的任何类型 B* b B b ，    但是只能嵌套自己的指针类型，因为这样才能确定大小
29.链表插入法 ^^(这个指向好理解)   ^（这个要中间变量去接） 两个指针法和一个指针法找pnew
30.函数指针 typedef (void*)(*PRINT)(int a,int b)可以定义多个         int(*p1)(int a)  = fun() 只有 一个p1变量   常用于回调函数 PRINT p  { p(x,y);}   还有函数指针数组int(*p1[3])(int a)={fun,fun1,fun2}
31.链表的翻转  交换next指针域  ^^^    三个指针找 第一个开始（head下一个）
32.递归  自己调用自己   里面有退出条件
33.预处理(头文件、宏定义、条件编译(调试#define D #ifdef D  ...   #endif )、宏定义一些函数等)-编译(汇编语言)-汇编(二进制)-连接(库连接)   #define  MAX(a,b)  (a)>(b)？(a):(b)   
34.指针调用值传递（平级传递） 、地址传递（需要更改值或释放地址）   
35.封装动态库
36.日志打印   别人的代码
37.检测内存泄漏   代码检测 每个平台有自己的代码
38.memcpy  与  strcpy   区别  memcpy 不会因为结束符而停止，全拷贝过来   而strcpy会因为结束符停止拷贝   memcpy更安全
